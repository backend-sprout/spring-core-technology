의존관계 주입
======================
> Spring에서 지원하는 의존관계는 크게 4가지가 있다.  
   
* **생성자 주입**     
* Setter 주입     
* 필드 주입      
* 일반 메서드 주입     

# 🕛 의존관계 주입 개요 - 스프링 컨테이너의 라이프 사이클   

스프링 컨테이너는 2단계의 라이프 사이클을 가진다.   
  
1. 스프링 빈을 등록  
2. 연관 관계를 자동으로 주입한다.  
  
앞서 여러 의존 관계 주입이 있다하였다.    
이들의 특징을 보면, **`생성자 주입`을 제외한 방법들은 빈이 생성된 후에 의존 관계 주입을 맺는다.**      
반대로 **`생성자 주입`은 의존 관계 주입이 되고 난 후에야 비로소 빈으로 등록될 수 있다.**        
    
이 점에서 `생성자 주입`은 객체가 내부 상태를 모두 안전하게 가지고 있음을 반증하기도 한다.          
물론 `상태 패턴`과 같은 디자인 패턴을 사용할 때는 `Setter 주입`이 유리할 수 도 있다.           

# 📗 생성자 주입  
> 이름 그대로 `생성자`를 통해서 의존 관계를 주입 받는 방법이다.   
     
* 생성자 호출시점에 딱 1번 호출되는 것이 보장된다.       
* **생성자 호출시점이기에 빈이 등록 되는 과정에서 연관된 의존 관계까지 묶어서 등록된다.**       
* **불변**, **필수** 의존관계에 사용된다.    
  
```java
@Component
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```
생성자 주입의 한 가지 특이점이 있는데 
바로, **생성자가 단 한 개뿐일 때 `@Autowired`를 자동으로 주입해준다.**     
(반대로 생성자가 2개라면, 단 하나의 생성자에만 `@Autowired`를 붙여주자)       
   
```java
@Component
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;

    public OrderServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```
생성자 주입은 **불변으로 만드는 것을 최대한 지향하기에** 강력하게 추천한다.     
            
# 📘 Setter 주입 
> Setter 메서드를 통해, 이와 연관된 필드의 값을 변경하는 의존 관계 주입 방법이다.     
  
* **선택**,**변경** 가능성이 있는 의존 관계에서 사용된다.    
* 자바빈 프로퍼티 규약의 `Setter 메서드` 방식을 사용하는 방법이다.     
  * 스프링에서는 `자바빈 프로퍼티 규약`을 이용한 자동화 기능이 많다.  
  * 대표적인 자동화 기능으로, `request 파라미터`에 대한 `setter`를 만들면 알아서 값을 주입받는다.   
  * `Setter 주입`도 이러한 자동화 중 하나이니 [자바빈 프로퍼티 규약](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=rbamtori&logNo=220760147541)에 대해서 알아보는 것을 추천한다.     
       
```java
@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

**만약, 생성자 주입이랑 Setter가 동시에 존재한다면? 🤔**        
실제로 돌려보면, **두 의존 관계 주입 방법 모두 실행되는 것을 알 수 있다.**     
사실, 앞서 말했듯이 두 의존 관계 주입 방법의 시점이 달라서 가능했던 것이다.   
          
# 📕 필드 주입        
> 이름 그대로 필드에 바로 주입하는 방법이다.    

* 코드가 간결하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
* DI 프레임워크가 없으면 아무것도 할 수 없다.
* 리플렉션으로 인한 기본 생성자가 필요하다
   
```java
@Component
public class OrderServiceImpl implements OrderService {

    @Autowired  private MemberRepository memberRepository;
    @Autowired  private DiscountPolicy discountPolicy;

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
    
}
```
```
    // NullPointer Exception 이 뜬다.
    @Test
    void fieldInjectionTest(){
        OrderServiceImpl orderService = new OrderServiceImpl();
        orderService.createOrder(1L, "itemA", 10000);
    }
```      
테스트 코드에서는 객체를 주입해줄 방법이 없어 `NullPointerException`이 발생한다.      
이를 해결하기 위해서는 억지로라도 불필요한 `Setter`를 만들어야한다.   

```java
    @Test
    void fieldInjectionTest(){
        OrderServiceImpl orderService = new OrderServiceImpl();
        
        orderService.setMemberRepository(new MemoryMemberRepository()); 	// setter 사용 
        orderService.setDiscountPolicy(new FixDiscountPolicy()); 		// setter 사용 

        orderService.createOrder(1L, "itemA", 10000);
    }
```
이러한 방식은 매우 좋지 않은 것으로 필드 의존 관계 주입은 거의 사용하지 말자!     
애플리케이션의 실제 코드와 관계 없는 테스트 코드,      
스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 코드의 가독성을 위해 특별한 용도로 사용하자        
  
## 📖 필드 주입과 Reflection
필드 주입은 한 가지 특이점이 있는데, **접근 지정자가 `private`여도 의존 관계를 주입할 수 있다.**        
이는 자바의 `Reflection`이라는 기능을 이용해서 빈을 주입하기 때문이다.      

```java
import java.util.Arrays;
import java.util.Objects;

public class ContainerService {
	
    //매개값으로 들어온 타입의 인스턴스를 반환하는 메소드
    public static <T> T getObject(Class<T> classType){
        T instance = createInstance(classType);
        Arrays.stream(classType.getDeclaredFields()).forEach(f -> {
        
            if(Objects.nonNull(f.getAnnotation(Inject.class))){
                Object fieldInstance = createInstance(f.getType());
                f.setAccessible(true);                                // private 필드에 접근이 가능하도록 설정한다.  
                try {
                    f.set(instance, fieldInstance); 	              // private 필드에 값을 넣는다.   
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
        });
        return instance;
    }
	
    //인스턴스를 만드는 메소드
    private static <T> T createInstance(Class<T> classType) {
        try {
            return classType.getConstructor(null).newInstance();
        } catch(Exception e){
            throw new RuntimeException(e);
        }
    }
}
```
리플렉션을 이용해 `private 필드`에 주입을 진행했고 이런 방법이 있다만 알아두자.   
참고로 리플렉션으로 객체를 만들기 위해서는 기본 생성자(파라미터가 없는)가 필요하므로 이점 숙지하자(JPA도 나온다)        
   
[참고 사이트](https://sas-study.tistory.com/271)    
      
# 📙 일반 메서드 주입
> 일반 메서드에서도 `@Autowired`를 통해 의존 관계 주입을 받을 수 있다.   

* 한번에 여러 필드를 주입받을 수 있다.   
* 하지만, 일반적으로 사용하지는 않는다.  

```java
@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    @Autowired
    public final void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

}
```
파라미터에 존재하는 여러 필드를 대상으로 의존받을 수 있다는 것이 장점이다.          
하지만, **만약 빈이 아닌 다른 필드가 하나라도 온다면?🤔 당연하게도 동작하지 않는다.**           
     
# 📓 의존관계 옵션처리    
`@Autowired(required=true/false)`를 이용하면 `의존 관계 주입`에 대한 선택여부를 지정할 수 있다.   
        
**자동 주입 대상을 `옵션`으로 처리하는 다양한 방법**           
* **@Autowired(required=false) :** 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안된다.      
* **org.springframework.lang.@Nullable :** 자동 주입할 대상이 없으면 `null`이 입력된다.    
* **Optional<> :** 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.    
       
# 📔 생성자 주입을 사용해라!    
최근, 스프링 프레임워크를 포함한 `DI 프레임워크` 대부분이 생성자 주입을 권장하고 있다.     
        
**불변**       
* 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.   
  오히려, 애플리케이션 종료 전까지 변하면 안된다.         
* 수정자 주입을 사용하면, 메서드를 public으로 열어두고 이로인해 변경 가능성이 높아진다.   
* 생성자 주입은 객체를 생성할 때, 딱 1번만 호출되므로 이후에 호출되는 일이 없다.   
      
**누락**        
`Setter 의존 관계 주입`을 기준으로 설명을 해보려 한다.     
      
프레임워크 없이 순수한 자바 코드를 이용한다고 가정 할 때            
우선, 객체를 생성하고, `Setter`를 통해서 의존 관계를 직접 넣어주어야한다.             
그런데 만약, `Setter` 호출을 하지 않는 경우는 어떻게 될까?              
   
아이러니하게도 **`컴파일 에러`가 발생하지 않으며 `NullPointerException`이 발생하는 것을 알 수 있다.**             
이렇듯, `Setter`는 일종의 메서드이기 때문에 호출을 누락할 수 있다는 문제점이 있다.   
        
반대로 생성자 중비을 사용하면 값이 없을 경우 컴파일 오류가 발생할 수 있으며   
개발자는 이로인해 자신의 코드를 실행 전에 수정할 수 있는 기회를 얻게된 셈이다.  
   
**final**   
생성자 주입을 사용하면 다른 의존 관계 주입 방법과는 다르게 `final`을 사용할 수 있게 된다.    
그래서 생성자를 통해 값을 설정하지 않는 실수를 발생한다면 이를 컴파일 에러로 막아준다.  

```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;		// 에러뜸
    private final DiscountPolicy discountPolicy;		// 에러뜸 

    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    	// 값 초기화 누락했다.  
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용도
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }

}
```
누락 단계에 사용되던 테스트 코드나,    
클래스 생성자 내부적으로 갑을 할당하는 경우를 누락했을 때,   
`final` 키워드가 없었다면 자연스럽게 로직이 수행되다가 `NullPointerException`이 뜰텐데   
`final` 키워드를 사용함으로써 컴파일 에러를 이끌어낼 수 있게 되었다.   
  
기억하자! **컴파일 에러는 세상에서 가장 빠르고, 좋은 오류다!**  

참고로,   
수정자 주입과 필드 주입은 빈을 생성한 후에 호출하기에 **필드에 `final` 키워드를 사용할 수 없으며,**    
`final` 키워드는 오직 생성자 주입에서만 가능하다.         

**정리**   
* 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만,   
  프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 하다.
* 윗말에 덧붙여 말하자면, 순수한 자바 언어의 특징을 살렸기에 테스트에도 용이하다  
* 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 
* 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
* 항상 생성자 주입을 선택해라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라. 
* 필드 주입은 사용하지않는게 좋다   



# 롬복과 최신 트랜드      
롬복은 주로 사용되는 반복 코드들을 대신 작성해주는 라이브러리이다.           
예를 들면 `Getter`, `Setter`, `ToString`, `생성자`와 같은 코드들이 있다.            
그리고 롬복은 **어노테이션 프로세서를 기반으로 동작을 한다.**     
    
**롬복 설정**

1. `Prefrences(윈도우 File Settings)` -> `plugin` -> `lombok` 검색 설치 실행 (재시작)
2. `Prefrences` -> `Annotation Processors` 검색 -> `Enable annotation processing` 체크 (재시작)
3. 임의의 테스트 클래스를 만들고 `@Getter, @Setter` 확인    
    * 필자같은 경우 community 사용시,   
      `Annotation Processors`이 동작안해서 런타임에러가 발생하는 겨웅가 종종 있었다.   
      그렇기에 애플리케이션을 `run`하기 전에 잘 돌아가는지 확인부터 하자.     
      
이후, `build.gradle`을 아래와 같이 변경해준다.  
   
**build.gradle**    
```java
plugins {
    id 'org.springframework.boot' version '2.4.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '1.8'

repositories {
    mavenCentral()
}

configurations {
    compileJava {
        extendsFrom annotationProcessor
    }
}

dependencies {
    implementation 'org.projectlombok:lombok'

    compileOnly'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    testCompileOnly'org.projectlombok:lombok'
    testAnnotationProcessor 'org.projectlombok:lombok'

    implementation 'org.springframework.boot:spring-boot-starter'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

test {
    useJUnitPlatform()
}
```

**적용 확인**
```java
package hello.core;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
public class HelloLombok {

    private String name;
    private int age;

    public static void main(String[] args) {
        HelloLombok helloLombok = new HelloLombok();
        helloLombok.setName("hi");
        System.out.println("helloLombok = " + helloLombok);

        String name = helloLombok.getName();
        System.out.println("name = " + name);
    }
}
```
위 코드를 보면 클래스에는 실질적인 `Getter/Setter` 메서드가 존재하지 않지만   
컴파일 에러도 없으며, 해당 메서드를 호출하고 사용하고 있음을 알 수 있다.     

**롬복으로 리팩터링 및 비교**
```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용도
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }

}

```

```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@RequiredArgsConstructor
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용도
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }

}
```  
롬복을 사용하면서, 매 클래스마다 반복적으로 작성해야할 코드들을 어노테이션으로 해결했다.         
참고로 위 코드는 생성자가 1개일 경우 `@Autowired`가 붙는다는 특징을 활용한 것이다.             
추가적으로, 필자(kwj1270)의 추천으로 `@Builder`라는 어노테이션도 있으니 이를 활용하면 좋을 것이며      
이외에도 [실무에서 유용한 롬복 사용법](https://cheese10yun.github.io/lombok/)에 대해서 YUN님이께서 정리해주셨으니 이점 참고하자    
          





    
    
  



