조회 빈이 2개 이상일 때(문제)       
====================================

`@Autowired`는 **타입(Type)을 기반으로 조회한다.**            
그렇기에 동일한 타입의 빈이 2개 존재한다면, 어떤 빈을 주입해야할지 모르기에 에러를 발생시킨다.       
     
```java
@Component    
class FixDiscountPolicy implements DiscountPolicy {}

@Component
class RateDiscountPolicy implements DiscountPolicy {}

@Service
public class SampleService {
    @Autowired
    private DiscountPolicy discountPolicy;
}
```
```sh
NoUniqueBeanDefinitionException: No qualifying bean of type 
'hello.core.discount.DiscountPolicy' available: expected single matching bean 
but found 2: fixDiscountPolicy,rateDiscountPolicy
```

위와 같은 코드가 주어졌을 때, `NoUniqueBeanDefinitionException` 오류가 발생한다.
        
단편적인 해결 방법으로 상위 타입이 아닌 구체적인 하위 타입으로 지정할 수도 있지만,      
**하위 타입으로 지정하는 것은 DIP를 위배시키고 유연성을 떨어뜨린다는 문제점에 사용에 알맞지 않다.**        
또한, **이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때는 해결이 안된다.**      

스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 아래와 같은 방법으로 해결할 수 있다.   
   
* @Autowired 필드명 매칭
* @Qualifier -> @Qualifier 끼리 매칭 -> 빈 이름 지정    
* @Primary 사용 

# 📕 @Autowired 필드명   
> `@Autowired`는 단순히 타입으로만 의존 관계 주입을 진행하는 것은 아니다.    

`@Autowired`는 아래와 같은 탐색 사이클을 갖는다.  

1. 타입 매칭
2. 필드 이름(필드 이름 == 빈 이름)  
3. 파라미터 이름(파라미터 이름 == 빈 이름)

즉, 여러 빈이 있으면 **타입 -> 필드 이름/파라미터 이름**으로 추가 매칭을 진행한다.    
    
**필드명을 기준으로 의존관계 주입**  
```java  
@Autowired
private DiscountPolicy rateDiscountPolicy
```

**파라미터 이름을 기준으로 의존관계 주입**   
```java
    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy rateDiscountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = rateDiscountPolicy;
    }
```

위와 같이 변수명의 이름을 빈의 식별 이름으로 지정해주면, 
2개 이상의 같은 타입의 빈이 있다하더라도 의존 관계를 주입 받을 수 있다.      
          
# 📘 @Qualifier 사용     
`@Qualifier` 는 **추가 구분자**를 붙여주는 방법이다.              
주입시 추가적인 방법을 제공하는 것이지 **빈 이름을 변경하는 것은 아니다!**         
**빈 식별을 위한 메타 데이터**라고 생각하면 이해하기 편하다.         

**RateDiscountPolicy**
```java
@Component
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {
    ...
}
```    
  
**FixDiscountPolicy**
```
@Component
@Qualifier("subDiscountPolicy")
public class FixDiscountPolicy implements DiscountPolicy {
    ...
}
```  
`@Qualifier`는 빈 식별을 위한 추가 구분자,식별 메타 데이터 제공 어노테이션이다.        
그렇기에 동일한 타입의 빈 등록시 `@Qualifier`를 통해 식별구문을 넣어준다.   
     
**OrderServiceImpl**
```java
    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, @Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
``` 
간단하게, **의존 관계 주입을 받을 객체 옆에 `@Qualifier("식별자")`를 붙여주면 된다.**                   
그러면 `DI 컨테이너`에서 해당하는 식별자를 가진 빈을 찾아서 의존 관계 주입을 맺어준다.          
     
**`@Qualifier`는 사용 가능 영역(단, 참조 변수 옆에 붙여야한다.)**        
* 필드 주입
* 생성자 주입
* Setter 주입
* 일반 메서드 주입
   
**@Qualifier 매칭 순서 정리**
1. 같은 식별자를 가진 `@Qualifier`끼리 매칭    
2. 빈 이름 매칭    
3. NoSuchBeanDefinitionException 예외 발생   
   
`@Qualifier`또한, `@Autowired`처럼     
지정한 식별자를 이름으로 갖는 빈을 추가로 찾는다.     
하지만, `@Qualifier`를 이용한 빈 조회시에는 이러한 방식을 사용하지 말고    
**`@Autowired`를 이용한 빈 찾기 + `@Qualifier` 추가 구분자** 로만 사용하자        
       
# 📗 @Primary   
> 필자(kwj1270)는 사용해본 경험이 없지만, 실무에서는 많이 사용하는 어노테이션 같다.     
               
`@Primary`는 의존 관계 주입시 **우선순위를 지정하는 메타 데이터 어노테이션이다.**          
쉽게 설명하면, 여러 동일한 타입의 빈들중 `@Primary`가 붙은 빈을 우선으로 주입 받는다.   

**RateDiscountPolicy**
```java
@Component
@Primary
public class RateDiscountPolicy implements DiscountPolicy {
    ...
}
```
**FixDiscountPolicy**
```java
@Component
public class FixDiscountPolicy implements DiscountPolicy {
    ...
}
```
동일한 타입을 가진 빈이 여럿 등록 될 때,      
메인이 되는 빈에 `@Primary` 어노테이션을 붙여준다.      
     
```java
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository,DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy; // RateDiscountPolicy 가 들어온다.  
    }
}
```   
`@Primary`가 붙었던 빈은 우선순위를 가지게 되는 것이기에 일반적인 주입 방법과 같이 사용할 수 있다.    
      
## 📖 @Primary VS @Qualifier
`@Primary` 와 `@Qualifier` 중에 어떤 것을 사용하면 좋을지 고민이 될 것이다.      
      
**추천 사용**
* `@Qualifier`는 모든 코드에 `@Qualifier` 를 붙여주어야 한다. 
* `@Primary`는 연관된 빈들에서 단 한번만 선언하면된다.            
* 결국, `@Qualifier` 이름을 맞춰주고 여러곳에 선언해야하니 관리하기 어렵다.        
* **그렇기에 @Primary 를 사용하는 것을 추천한다**       	    
* 물론, 2개를 혼합해서 사용해도 된다.  	         
       
**우선순위**      
* `@Primary`와 `@Qualifier` 2개가 함께 사용된다면 **@Qualifier** 가 우선권이 높다.     

# 어노테이션 직접 만들기       
`@Qualifier("mainDiscountPolicy")` 의 문제점이 무엇인지 보이는가?    
사실 이러한 부분은 `클린코드`에 대해서 공부를 해야 조금은 보인다.   
  
`@Qualifier("mainDiscountPolicy")`의 문제점은 바로 문자열이다.        
이렇게 문자열 적으면 컴파일시 타입 체크가 안 된다는 문제가 발생한다.     
즉, 내가 문자열에 오타를 냈는지 또는 알맞는 문자열을 넣었는지 어노테이션은 모른다.    
        
그렇기에 이와 같은 문제점을 해결하기 위해 상수를 사용하거나 클래스를 만드는 등          
 우리는 **타입의 안정성(type safety)** 을 위해 코드를 개선해야한다.        
         
우선 위와 같은 상황은 커스텀 어노테이션을 만들어서 문제를 해결할 수 있다.   
  
**커스텀 어노테이션 - MainDiscountPolicy**   
```java
package hello.core.annotation;

import org.springframework.beans.factory.annotation.Qualifier;

import java.lang.annotation.*;

@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Qualifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {
}
``` 
`@Qualifier`는 메타 어노테이션이기에 어노테이션 정의시 사용할 수 있다.       
이 점을 이용하여 특정 문자열을 가진 `@Qualifier`를 커스텀 어노테이션으로 만들 수 있다.        
이 경우, 특정 문자열을 가졌으므로 문자열 타입에 대해서 상수와 같은 안정성을 줄 수 있다.        
     
이제 이 커스텀 어노테이션을 실제 코드에 적용해보자    
      
**어노테이션 적용 - 빈**
```java
package hello.core.discount;

import hello.core.annotation.MainDiscountPolicy;
import hello.core.member.Grade;
import hello.core.member.Member;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;

@MainDiscountPolicy
@Component
public class RateDiscountPolicy implements DiscountPolicy {

    private int discountPercent = 10;

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return price * discountPercent / 100;
        }
        return 0;
    }
}
```

**어노테이션 적용 - DI**
```java
package hello.core.order;

import hello.core.annotation.MainDiscountPolicy;
import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository,@MainDiscountPolicy DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    // 테스트 용도
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }

}
```
잘 동작하는걸 확인할 수 있다.  
           
**어노테이션에는 상속이라는 개념이 없다.**            
이렇게 여러 애노테이션을 모아서 사용하는 기능은 스프링이 지원해주는 기능이다.            
정확히 말하자면 `@Qulifier`을 스프링에서 메타 어노테이션으로 지정했기에 가능한 것이다.        
`@Qulifier` 뿐만 아니라 다른 애노테이션들도 함께 조합해서 사용할 수 있다.    
단적으로 `@Autowired`도 재정의 할 수 있다.       
물론 스프링이 제공하는 기능을 뚜렷한 목적 없이 무분별하게 재정의하는 것은      
유지보수에 더 혼란만 가중할 수 있으므로 사용 전 충분히 검토후 사용하길 바란다.   


# 조회한 빈이 모두 필요할 때, List, Map  
지금까지는 여러개의 빈이 있을 때 단 한개만을 조회하는 방법에 대해서 배웠다.        
하지만 간혹, 같은 타입의 여러개의 빈을 전부 사용해야할 때도 있다.                
예제를 예시로 들면, 이제 사용자가 원하는 할인 정보를 선택하는 것이 해당된다.       
    
**그런데 어떻게 사용을 하지? 🤔**     
스프링을 사용하면 소위 말하는 **전략 패턴**을 매우 간단히 구현할 수 있다.    

```java
package hello.core.autowired;

import hello.core.AutoAppConfig;
import hello.core.discount.DiscountPolicy;
import hello.core.member.Grade;
import hello.core.member.Member;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

public class AllBeanTest {

    @Test
    void findAllBean() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);
        DiscountService discountService = ac.getBean(DiscountService.class);

        Member member = new Member(1L, "userA", Grade.VIP);
        int fixDiscountPrice = discountService.discount(member, 10000, "fixDiscountPolicy");

        assertThat(discountService).isInstanceOf(DiscountService.class);
        assertThat(fixDiscountPrice).isEqualTo(1000);

        int rateDiscountPrice = discountService.discount(member, 20000, "rateDiscountPolicy");

        assertThat(discountService).isInstanceOf(DiscountService.class);
        assertThat(rateDiscountPrice).isEqualTo(2000);
    }

    static class DiscountService {
        private final Map<String, DiscountPolicy> policyMap;
        private final List<DiscountPolicy> policies;

        @Autowired
        public DiscountService(Map<String, DiscountPolicy> policyMap, List<DiscountPolicy> policies) {
            System.out.println("policyMap = " + policyMap);
            System.out.println("policies = " + policies);
            this.policyMap = policyMap;
            this.policies = policies;
        }

        public final int discount(Member member, int price, String discountCode) {
            DiscountPolicy discountPolicy = policyMap.get(discountCode);
            return discountPolicy.discount(member, price);
        }
    }
}
```
위와 같이 코드가 있다고 가정을 하자     
스프링에서는 친절하게도 `Collection 주입` 또한 지원해준다.         
정확히 말하면 같은 타입의 여러 빈이 존재할 경우    
그리고 필드나 파라미터 변수의 타입이 `Collection`,`List`, `Map`일 경우      
이를 컬렉션으로 넘겨주어 한 번에 의존 관계를 맺게 해준다.          
       
이 점을 잘 이용한다면,           
`Map`에서 각각의 객체를 바로 꺼내 코드의 변경없이 다양한 전략을 구현시킬 수 있다.        

# 자동, 수동의 올바른 실무 운영 기준     
> 어떤 기준을 가지고 자동과 수동을 나누어 사용할까?   
       
**편리한 자동 기능을 수행하자**          
스프링이 나오고, 시간이 지날수록 점점 자동을 선호하는 추세가 되고 있다.       
최근 스프링 부트가 등장하면서, 컴포넌트 스캔을 기본으로 사용하고       
스프링 부트의 다양한 스프링 빈들도 조건만 맞으면 자동으로 등록하도로 설계되어 있다.     
   
설정 정보를 기반으로 애플리케이션을 구성하는 부분과 (AppConfig)        
실제 동작하는 부분을 명확하게 나누는 것이 이상적이지만, (MVC)         
개발자 입장에서 `@Componenet`만 붙이면 끝나게 될 것을        
일일히 자바 코드를 작성하고 주입할 대상을 일일히 관리하는 것은 여간 귀찮은 일이다.      
물론, 이 같은 방법을 이용하면 `OCP/DIP`원칙을 지키는데 상당수 유리하다.     
하지만, 결정적으로 자동 빈 등록을 사용해도 `OCP/DIP` 원칙을 지킬 수 있다.     
   
**수동 빈 등록은 언제 사용할까?**     
애플리케이션은 크게 **업무 로직**과 **기술 지원 로직**으로 나눌 수 있다.   
   
* **업무 로직 빈 :** 
  웹을 지원하는 `컨트롤러`, 핵심 비즈니스 로직이 있는 `서비스`,    
  데이터 계층의 로직을 처리하는 `리포지토리`등이 모두 업무 로직이다.   
  보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.   
* **기술 지원 빈 :**   
  기술적인 문제나 `공통 관심사(AOP)`를 처리할 때 주로 사용된다.   
  `데이터베이스 연결`이나, `공통 로그 처리`처럼    
  업무 로직을 지원하기 위한 하부 기술이나 공통 기술들     
   
업무 로직은 숫자도 매우 많고,   
한번 개발해야하면 `컨트롤러`/`서비스`/`리포지토리` 처럼 어느정도 유사한 패턴이 있다.     
이런 경우 자동 기능을 적극 사용하는 것이 좋다. (정형화된 패턴이 있으므로) 
보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽기 때문이다.     
    
기술지원 로직은 업무 로직과 비교해서 그 수가 매우 적고,         
보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다.       
그리고 기술 지원 로직은 적용이 잘 되고 있는지 아닌지 파악하기 힘든 경우가 많기에       
`AppConfig`처럼 가급적 수동 빈 등록을 사용해서 어떤 빈을 사용하는지 명확하게 드러내는 것이 좋다.     
     
**애플리케이션에 광범위하게 미치는 기술 지원 객체는     
수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다!**      
   
하지만, 간혹 비즈니스 로직 중에서도 수동 빈 등록이 유용한 경우도 있다.   
바로, **비즈니스 로직 중에서 `다형성`을 적극 활용할 때**이다.   
의존관계 자동 주입, 조회한 빈이 모두 필요할 때의 `List`, `Map`을 다시보자    
    
`DiscountService` 가 의존관계 자동 주입으로 `Map<String, DiscountPolicy>` 에 주입을 받는 상황을 생각해보자.    
여기에 어떤 빈들이 주입될 지, 각 빈들의 이름은 무엇일지 코드만 보고 한번에 쉽게 파악할 수 있을까?      
내가 개발했으니 크게 관계가 없지만, 만약 이 코드를 다른 개발자가 개발해서 나에게 준 것이라면 어떨까?     
         
이 부분을 조금 더 쉽게 표현하면 이렇다.           
우리는 `OCP/DIP` 원칙을 최대한 지키기 위해 다형성 및 다양한 디자인 패턴을 사용한다.         
그 과정에서 똑같은 인터페이스를 의존하지만 이를 구현한 각각의 구현체들도 많이 존재할 것이다.      
그런데 이런 구현체들을 자동으로 빈 등록을 할 수 있지만, 이들을 한 번에 묶어서 관리하기가 힘들다.      
또한, 자동 등록을 사용하고 있기 때문에 전부 파악하려면 여러 코드를 찾아봐야 한다.              
이런 경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어두는편이 좋다!      
핵심은 딱 보고 이해가 되어야 한다!    

```java
@Configuration
public class DiscountPolicyConfig {
 
    @Bean
    public DiscountPolicy rateDiscountPolicy() {
        return new RateDiscountPolicy();
    }
    @Bean
    public DiscountPolicy fixDiscountPolicy() {
        return new FixDiscountPolicy();
    }
}
```
위와 같은 설정 정보만 보더라도   
어떤 빈들이 존재하는지 그리고 어떻게 관리하는지 한 눈에 알 수 있게된다.   
   
하지만, 그래도 빈 자동 등록을 사용하고 싶으면      
파악하기 좋게 `DiscountPolicy` 의 구현 빈들만 따로 모아서 특정 패키지에 모아두자.     
      
**참고로 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외다.**          
이런 부분들은 스프링 자체를 잘 이해하고 스프링의 의도대로 잘 사용하는게 중요하다.         
부트의 경우 `DataSource` 같은 데이터베이스 연결에 사용하는 기술 지원 로직까지 내부에서 자동으로 등록하는데,    
이런 부분은 메뉴얼을 잘 참고해서 스프링 부트가 의도한 대로 편리하게 사용하면 된다.           
반면에 내가 직접 기술 지원 객체를스프링 빈으로 등록한다면 수동으로 등록해서 명확하게 들어내는 것이 좋다.       
      
**정리**      
* 편리한 자동 기능을 기본으로 사용하자   
* 직접 등록하는 기술 지원 객체는 수동 등록    
* 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자    


